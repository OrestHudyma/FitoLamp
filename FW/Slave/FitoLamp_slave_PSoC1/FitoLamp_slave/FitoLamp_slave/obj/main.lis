 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area lit(rom, con, rel, lit)
 0000           _schedule::
 0000 0005              .word 5
 0002 36B0              .word 14000
 0004 0014              .word 20
 0006 36B0              .word 14000
 0008                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
 0008                   .dbsym e schedule _schedule A[8:2:2]ki
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
 0000           _power_target::
 0000 0000              .word 0
 0002                   .dbsym e power_target _power_target i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
 0000           _NMEA_buffer::
 0000 4E4D45415F62756666657200  .byte 'N,'M,'E,'A,95,'b,'u,'f,'f,'e,'r,0
 000C 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 0048 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 0052                   .dbsym e NMEA_buffer _NMEA_buffer A[82:82]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
 0000           _NMEA_GPRMC::
 0000 4750524D4300      .byte 'G,'P,'R,'M,'C,0
 0006 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 0042 00000000000000000000      .word 0,0,0,0,0
 004C 000000000000      .byte 0,0,0,0,0,0
 0052                   .dbsym e NMEA_GPRMC _NMEA_GPRMC A[82:82]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
 0000           _gps_datetime::
 0000 00                .byte 0
 0001 00                .byte 0
 0002 00                .byte 0
 0003 00                .byte 0
 0004 00                .byte 0
 0005 00                .byte 0
 0006 0000              .word 0
 0008                   .dbstruct 0 8 datetime
 0008                   .dbfield 0 sec c
 0008                   .dbfield 1 min c
 0008                   .dbfield 2 hour c
 0008                   .dbfield 3 day c
 0008                   .dbfield 4 month c
 0008                   .dbfield 5 year c
 0008                   .dbfield 6 valid I
 0008                   .dbend
 0008                   .dbsym e gps_datetime _gps_datetime S[datetime]
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
 0000           _local_datetime::
 0000 00                .byte 0
 0001 00                .byte 0
 0002 00                .byte 0
 0003 00                .byte 0
 0004 00                .byte 0
 0005 00                .byte 0
 0006 0000              .word 0
 0008                   .dbsym e local_datetime _local_datetime S[datetime]
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
 0000                   .dbfunc e nmea_signal _nmea_signal fV
 0000           ;              i -> X+0
 0000           _nmea_signal::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3803              add SP,3
 0004                   .dbline 88
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>        // part specific constants and macros
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; #include "delay.h"
 0004           ; #include <stdlib.h>
 0004           ; #include <stdio.h>
 0004           ; #include <math.h> 
 0004           ; #include <stdbool.h>
 0004           ; #include <string.h>
 0004           ; 
 0004           ; #define DEBUG
 0004           ; 
 0004           ; #define DECIMAL_COUNT_SYSTEM_BASIS  10
 0004           ; #define DECIMAL_NUMBER_SIZE         4
 0004           ; #define HOUR_MAX                          23
 0004           ; #define DELAYS_IN_SECOND              100
 0004           ; 
 0004           ; // NMEA definitions
 0004           ; #define NMEA_MAX_SIZE             82
 0004           ; #define NMEA_START_DELIMITER      '$'
 0004           ; #define NMEA_END_DELIMITER        0x0A
 0004           ; #define NMEA_CHECKSUM_DELIMITER   '*'
 0004           ; #define NMEA_FIELD_DELIMITER      ','
 0004           ; #define NMEA_HEADER_SIZE          3
 0004           ; 
 0004           ; #define NMEA_GPRMC_UTC              1
 0004           ; #define NMEA_GPRMC_SATELLITES       7
 0004           ; #define NMEA_GPRMC_HDOP             8
 0004           ; #define NMEA_GPRMC_ALTITUDE         9
 0004           ; 
 0004           ; #define NMEA_GPRMC_VALID            'A'
 0004           ; #define NMEA_GPRMC_INVALID          'V'
 0004           ; 
 0004           ; // System settings
 0004           ; #define POWER_MAX     14000
 0004           ; #define POWER_STEP    1
 0004           ; #define GMT_OFFSET    3
 0004           ; 
 0004           ; #define WAIT_PERIOD                   2               // Global non critical tasks execution period in seconds
 0004           ; #define POWER_UPDATE_SLOW   2000
 0004           ; #define POWER_UPDATE_FAST   200
 0004           ; 
 0004           ; unsigned int const schedule[2][2] = {
 0004           ;                                               {5, POWER_MAX},
 0004           ;                                               {20, POWER_MAX}
 0004           ;                                               };
 0004           ; 
 0004           ; struct datetime {
 0004           ;       unsigned char sec;
 0004           ;       unsigned char min;
 0004           ;       unsigned char hour;
 0004           ;       unsigned char day;
 0004           ;       unsigned char month;
 0004           ;       unsigned char year;
 0004           ;       bool valid;
 0004           ; };
 0004           ; 
 0004           ; unsigned int power_target = 0;
 0004           ; 
 0004           ; // NMEA variables
 0004           ; char NMEA_buffer[NMEA_MAX_SIZE] = "NMEA_buffer";
 0004           ; char NMEA_GPRMC[NMEA_MAX_SIZE] = "GPRMC";
 0004           ; unsigned char NMEA_pointer;
 0004           ; 
 0004           ; struct datetime gps_datetime = {0, 0, 0, 0, 0, 0, false};
 0004           ; struct datetime local_datetime = {0, 0, 0, 0, 0, 0, false};
 0004           ; 
 0004           ; void set_power(unsigned int pwr);
 0004           ; void update_power(void);
 0004           ; void schedule_processing(unsigned char hour);
 0004           ; void schedule_init(void);
 0004           ; void rtc_update(struct datetime *datetime);
 0004           ; 
 0004           ; // NMEA functions
 0004           ; void NMEA_handle_packet(char *packet, char *NMEA_data);
 0004           ; void NMEA_GetField(char *packet, unsigned char field, char *result);
 0004           ; void NMEA_GetTimeUTC(char *gprmc, struct datetime *gps_datetime);
 0004           ; 
 0004           ; unsigned char str_cmp(char *str1, char *str2, unsigned char stop);
 0004           ; unsigned char byte_to_bcd(unsigned char byte);
 0004           ; unsigned char bcd_to_byte(unsigned char reg);
 0004           ; void utc_to_local(struct datetime *gps_datetime, struct datetime *local_datetime);
 0004           ; 
 0004           ; void nmea_signal(void)
 0004           ; {
 0004                   .dbline 90
 0004           ;       unsigned char i;
 0004           ;       if (NMEA_pointer >= NMEA_MAX_SIZE) NMEA_pointer = 0;
 0004 62D000            mov REG[0xd0],>_NMEA_pointer
 0007 3C0052            cmp [_NMEA_pointer],82
 000A C007              jc L2
 000C           X0:
 000C                   .dbline 90
 000C 62D000            mov REG[0xd0],>_NMEA_pointer
 000F 550000            mov [_NMEA_pointer],0
 0012           L2:
 0012                   .dbline 91
 0012           ;     NMEA_buffer[NMEA_pointer] = RX8_GPS_bReadRxData();        
 0012 10                push X
 0013 7C0000            xcall _RX8_GPS_bReadRxData
 0016 20                pop X
 0017 62D000            mov REG[0xd0],>__r0
 001A 5300              mov [__r0],A
 001C 62D000            mov REG[0xd0],>_NMEA_pointer
 001F 5100              mov A,[_NMEA_pointer]
 0021 62D000            mov REG[0xd0],>__r0
 0024 5300              mov [__r3],A
 0026 550000            mov [__r2],0
 0029 060000            add [__r3],<_NMEA_buffer
 002C 0E0000            adc [__r2],>_NMEA_buffer
 002F 5100              mov A,[__r2]
 0031 60D5              mov REG[0xd5],A
 0033 5100              mov A,[__r0]
 0035 3F00              mvi [__r3],A
 0037                   .dbline 92
 0037           ;     NMEA_buffer[NMEA_pointer + 1] = 0;        
 0037 62D000            mov REG[0xd0],>_NMEA_pointer
 003A 5100              mov A,[_NMEA_pointer]
 003C 62D000            mov REG[0xd0],>__r0
 003F 5300              mov [__r1],A
 0041 550000            mov [__r0],0
 0044 060001            add [__r1],<_NMEA_buffer+1
 0047 0E0001            adc [__r0],>_NMEA_buffer+1
 004A 5100              mov A,[__r0]
 004C 60D5              mov REG[0xd5],A
 004E 5000              mov A,0
 0050 3F00              mvi [__r1],A
 0052                   .dbline 93
 0052           ;     switch(NMEA_buffer[NMEA_pointer])
 0052 62D000            mov REG[0xd0],>_NMEA_pointer
 0055 5100              mov A,[_NMEA_pointer]
 0057 62D000            mov REG[0xd0],>__r0
 005A 5300              mov [__r1],A
 005C 550000            mov [__r0],0
 005F 060000            add [__r1],<_NMEA_buffer
 0062 0E0000            adc [__r0],>_NMEA_buffer
 0065 5100              mov A,[__r0]
 0067 60D4              mov REG[0xd4],A
 0069 3E00              mvi A,[__r1]
 006B 5402              mov [X+2],A
 006D 560100            mov [X+1],0
 0070 5202              mov A,[X+2]
 0072 110A              sub A,10
 0074 5300              mov [__rY],A
 0076 5201              mov A,[X+1]
 0078 3180              xor A,-128
 007A 1980              sbb A,(0 ^ 0x80)
 007C C02B              jc L5
 007E 2A00              or A,[__rY]
 0080 A015              jz L9
 0082           X1:
 0082           L10:
 0082 3D0100            cmp [X+1],0
 0085 B006              jnz X2
 0087 3D0224            cmp [X+2],36
 008A A003              jz L8
 008C           X2:
 008C 801B              xjmp L5
 008E           L8:
 008E                   .dbline 96
 008E           ;     {
 008E           ;         case NMEA_START_DELIMITER:
 008E           ;         NMEA_pointer = 0;
 008E 62D000            mov REG[0xd0],>_NMEA_pointer
 0091 550000            mov [_NMEA_pointer],0
 0094                   .dbline 97
 0094           ;         break;
 0094 8018              xjmp L6
 0096           L9:
 0096                   .dbline 100
 0096           ;         
 0096           ;         case NMEA_END_DELIMITER:
 0096           ;         NMEA_handle_packet(NMEA_buffer, NMEA_GPRMC);
 0096 5000              mov A,>_NMEA_GPRMC
 0098 08                push A
 0099 5000              mov A,<_NMEA_GPRMC
 009B 08                push A
 009C 5000              mov A,>_NMEA_buffer
 009E 08                push A
 009F 5000              mov A,<_NMEA_buffer
 00A1 08                push A
 00A2 93F5              xcall _NMEA_handle_packet
 00A4 38FC              add SP,-4
 00A6                   .dbline 101
 00A6           ;         break;
 00A6 8006              xjmp L6
 00A8           L5:
 00A8                   .dbline 104
 00A8           ;         
 00A8           ;         default:
 00A8           ;         NMEA_pointer++;
 00A8 62D000            mov REG[0xd0],>_NMEA_pointer
 00AB 7600              inc [_NMEA_pointer]
 00AD                   .dbline 105
 00AD           ;         break;
 00AD           L6:
 00AD                   .dbline -2
 00AD           L1:
 00AD 38FD              add SP,-3
 00AF 20                pop X
 00B0                   .dbline 0 ; func end
 00B0 7F                ret
 00B1                   .dbsym l i 0 c
 00B1                   .dbend
 00B1                   .dbfunc e main _main fV
 00B1           ;              t -> X+0
 00B1           _main::
 00B1                   .dbline -1
 00B1 10                push X
 00B2 4F                mov X,SP
 00B3 3801              add SP,1
 00B5                   .dbline 110
 00B5           ;     }
 00B5           ; }
 00B5           ; 
 00B5           ; void main(void)
 00B5           ; {
 00B5                   .dbline 113
 00B5           ;       unsigned char t;
 00B5           ;       
 00B5           ;       M8C_EnableGInt; // Uncomment this line to enable Global Interrupts
 00B5 7101                      or  F, 01h
 00B7           
 00B7                   .dbline 115
 00B7           ; 
 00B7           ;       RTC_SetHour(0x08);
 00B7 10                push X
 00B8 5008              mov A,8
 00BA 7C0000            xcall _RTC_SetHour
 00BD                   .dbline 116
 00BD           ;       RTC_SetMinute(0x00);
 00BD 5000              mov A,0
 00BF 7C0000            xcall _RTC_SetMinute
 00C2                   .dbline 117
 00C2           ;       RTC_SetSecond(0x00);
 00C2 5000              mov A,0
 00C4 7C0000            xcall _RTC_SetSecond
 00C7                   .dbline 118
 00C7           ;       RTC_Start();
 00C7 7C0000            xcall _RTC_Start
 00CA                   .dbline 119
 00CA           ;       PWM16_CH0_Start();
 00CA 7C0000            xcall _PWM16_CH0_Start
 00CD                   .dbline 120
 00CD           ;       PWM16_CH1_Start();
 00CD 7C0000            xcall _PWM16_CH1_Start
 00D0                   .dbline 121
 00D0           ;       Counter16_PwrUpd_Start();
 00D0 7C0000            xcall _Counter16_PwrUpd_Start
 00D3                   .dbline 122
 00D3           ;       RX8_GPS_Start(RX8_GPS_PARITY_NONE);
 00D3 5000              mov A,0
 00D5 7C0000            xcall _RX8_GPS_Start
 00D8                   .dbline 125
 00D8           ;       
 00D8           ; #ifdef DEBUG
 00D8           ;       LCD_Init();
 00D8 7C0000            xcall _LCD_Init
 00DB                   .dbline 126
 00DB           ;       LCD_Position(0, 0);
 00DB 5000              mov A,0
 00DD 5700              mov X,0
 00DF 7C0000            xcall _LCD_Position
 00E2                   .dbline 127
 00E2           ;       LCD_PrCString(" ");
 00E2 5008              mov A,>L12
 00E4 08                push A
 00E5 5008              mov A,<L12
 00E7 5C                mov X,A
 00E8 18                pop A
 00E9 7C0000            xcall _LCD_PrCString
 00EC                   .dbline 130
 00EC           ; #endif // DEBUG
 00EC           ;       
 00EC           ;       RX8_GPS_EnableInt();
 00EC 7C0000            xcall _RX8_GPS_EnableInt
 00EF                   .dbline 131
 00EF           ;       Counter16_PwrUpd_EnableInt();
 00EF 7C0000            xcall _Counter16_PwrUpd_EnableInt
 00F2                   .dbline 133
 00F2           ;               
 00F2           ;       Counter16_PwrUpd_WritePeriod(POWER_UPDATE_SLOW);
 00F2 5707              mov X,7
 00F4 50D0              mov A,-48
 00F6 7C0000            xcall _Counter16_PwrUpd_WritePeriod
 00F9 20                pop X
 00FA                   .dbline 134
 00FA           ;       set_power(POWER_MAX);
 00FA 5036              mov A,54
 00FC 08                push A
 00FD 50B0              mov A,-80
 00FF 08                push A
 0100 90AD              xcall _set_power
 0102 38FE              add SP,-2
 0104 80A3              xjmp L14
 0106           L13:
 0106                   .dbline 137
 0106           ;       
 0106           ;       while (1)
 0106           ;       {
 0106                   .dbline 138
 0106           ;               M8C_DisableGInt;
 0106 70FE                      and F, FEh
 0108           
 0108                   .dbline 141
 0108           ;               
 0108           ;               // Get datetime
 0108           ;               local_datetime.valid = false;
 0108 62D000            mov REG[0xd0],>_local_datetime
 010B 550700            mov [_local_datetime+6+1],0
 010E 550600            mov [_local_datetime+6],0
 0111                   .dbline 142
 0111           ;               NMEA_GetTimeUTC(NMEA_GPRMC, &gps_datetime);
 0111 5000              mov A,>_gps_datetime
 0113 08                push A
 0114 5000              mov A,<_gps_datetime
 0116 08                push A
 0117 5000              mov A,>_NMEA_GPRMC
 0119 08                push A
 011A 5000              mov A,<_NMEA_GPRMC
 011C 08                push A
 011D 9488              xcall _NMEA_GetTimeUTC
 011F 38FC              add SP,-4
 0121                   .dbline 143
 0121           ;               if(gps_datetime.valid) 
 0121 62D000            mov REG[0xd0],>_gps_datetime
 0124 3C0600            cmp [_gps_datetime+6],0
 0127 B006              jnz X4
 0129 3C0700            cmp [_gps_datetime+6+1],0
 012C A019              jz L17
 012E           X4:
 012E                   .dbline 145
 012E           ;               {
 012E           ;                       utc_to_local(&gps_datetime, &local_datetime);
 012E                   .dbline 145
 012E 5000              mov A,>_local_datetime
 0130 08                push A
 0131 5000              mov A,<_local_datetime
 0133 08                push A
 0134 5000              mov A,>_gps_datetime
 0136 08                push A
 0137 5000              mov A,<_gps_datetime
 0139 08                push A
 013A 9636              xcall _utc_to_local
 013C                   .dbline 146
 013C           ;                       rtc_update(&local_datetime);
 013C 5000              mov A,>_local_datetime
 013E 08                push A
 013F 5000              mov A,<_local_datetime
 0141 08                push A
 0142 91B8              xcall _rtc_update
 0144 38FA              add SP,-6
 0146                   .dbline 147
 0146           ;               }
 0146           L17:
 0146                   .dbline 150
 0146           ;               
 0146           ;               // Scheduler
 0146           ;               schedule_init();
 0146 918A              xcall _schedule_init
 0148                   .dbline 153
 0148           ;                       
 0148           ;               #ifdef DEBUG
 0148           ;                       LCD_Position(0, 0);
 0148 10                push X
 0149 5000              mov A,0
 014B 5700              mov X,0
 014D 7C0000            xcall _LCD_Position
 0150                   .dbline 154
 0150           ;                       LCD_PrHexByte(RTC_bReadHour());
 0150 7C0000            xcall _RTC_bReadHour
 0153 20                pop X
 0154 62D000            mov REG[0xd0],>__r0
 0157 10                push X
 0158 7C0000            xcall _LCD_PrHexByte
 015B                   .dbline 155
 015B           ;                       LCD_Position(0, 3);
 015B 5703              mov X,3
 015D 5000              mov A,0
 015F 7C0000            xcall _LCD_Position
 0162                   .dbline 156
 0162           ;                       LCD_PrHexByte(RTC_bReadMinute());
 0162 7C0000            xcall _RTC_bReadMinute
 0165 20                pop X
 0166 62D000            mov REG[0xd0],>__r0
 0169 10                push X
 016A 7C0000            xcall _LCD_PrHexByte
 016D                   .dbline 157
 016D           ;                       LCD_Position(0, 6);
 016D 5706              mov X,6
 016F 5000              mov A,0
 0171 7C0000            xcall _LCD_Position
 0174                   .dbline 158
 0174           ;                       LCD_PrHexByte(RTC_bReadSecond());
 0174 7C0000            xcall _RTC_bReadSecond
 0177 20                pop X
 0178 62D000            mov REG[0xd0],>__r0
 017B 10                push X
 017C 7C0000            xcall _LCD_PrHexByte
 017F                   .dbline 160
 017F           ;                       
 017F           ;                       LCD_Position(1, 0);
 017F 5700              mov X,0
 0181 5001              mov A,1
 0183 7C0000            xcall _LCD_Position
 0186                   .dbline 161
 0186           ;                       LCD_PrHexInt(PWM16_CH0_wReadPulseWidth());                      
 0186 7C0000            xcall _PWM16_CH0_wReadPulseWidth
 0189 62D000            mov REG[0xd0],>__r0
 018C 10                push X
 018D 20                pop X
 018E 7C0000            xcall _LCD_PrHexInt
 0191 20                pop X
 0192                   .dbline 164
 0192           ;               #endif // DEBUG
 0192           ;                       
 0192           ;               M8C_EnableGInt;
 0192 7101                      or  F, 01h
 0194           
 0194                   .dbline 165
 0194           ;               for (t=0; t<=DELAYS_IN_SECOND; t++)     Delay10msTimes(WAIT_PERIOD);
 0194 560000            mov [X+0],0
 0197 800A              xjmp L23
 0199           L20:
 0199                   .dbline 165
 0199 10                push X
 019A 5002              mov A,2
 019C 7C0000            xcall _Delay10msTimes
 019F 20                pop X
 01A0           L21:
 01A0                   .dbline 165
 01A0 7700              inc [X+0]
 01A2           L23:
 01A2                   .dbline 165
 01A2 5064              mov A,100
 01A4 3B00              cmp A,[X+0]
 01A6 DFF2              jnc L20
 01A8           X5:
 01A8                   .dbline 166
 01A8           ;       }
 01A8           L14:
 01A8                   .dbline 136
 01A8 8F5D              xjmp L13
 01AA           X3:
 01AA                   .dbline -2
 01AA           L11:
 01AA 38FF              add SP,-1
 01AC 20                pop X
 01AD                   .dbline 0 ; func end
 01AD 8FFF              jmp .
 01AF                   .dbsym l t 0 c
 01AF                   .dbend
 01AF                   .dbfunc e set_power _set_power fV
 01AF           ;            pwr -> X-5
 01AF           _set_power::
 01AF                   .dbline -1
 01AF 10                push X
 01B0 4F                mov X,SP
 01B1                   .dbline 170
 01B1           ; }
 01B1           ; 
 01B1           ; void set_power(unsigned int pwr)
 01B1           ; {
 01B1                   .dbline 171
 01B1           ;       if(pwr > POWER_MAX) pwr = POWER_MAX;
 01B1 50B0              mov A,-80
 01B3 13FC              sub A,[X-4]
 01B5 5036              mov A,54
 01B7 1BFB              sbb A,[X-5]
 01B9 D007              jnc L25
 01BB           X6:
 01BB                   .dbline 171
 01BB 56FCB0            mov [X-4],-80
 01BE 56FB36            mov [X-5],54
 01C1           L25:
 01C1                   .dbline 172
 01C1           ;       power_target = pwr;
 01C1 62D000            mov REG[0xd0],>_power_target
 01C4 52FC              mov A,[X-4]
 01C6 5301              mov [_power_target+1],A
 01C8 52FB              mov A,[X-5]
 01CA 5300              mov [_power_target],A
 01CC                   .dbline -2
 01CC           L24:
 01CC 20                pop X
 01CD                   .dbline 0 ; func end
 01CD 7F                ret
 01CE                   .dbsym l pwr -5 i
 01CE                   .dbend
 01CE                   .dbfunc e update_power _update_power fV
 01CE           ;            pwr -> X+0
 01CE           _update_power::
 01CE                   .dbline -1
 01CE 10                push X
 01CF 4F                mov X,SP
 01D0 3802              add SP,2
 01D2                   .dbline 176
 01D2           ; }
 01D2           ; 
 01D2           ; void update_power(void)
 01D2           ; {
 01D2                   .dbline 180
 01D2           ;       unsigned int pwr;
 01D2           ;       
 01D2           ;       // CH0
 01D2           ;       pwr = PWM16_CH0_wReadPulseWidth();
 01D2 10                push X
 01D3 7C0000            xcall _PWM16_CH0_wReadPulseWidth
 01D6 62D000            mov REG[0xd0],>__r0
 01D9 5A00              mov [__r0],X
 01DB 20                pop X
 01DC 5401              mov [X+1],A
 01DE 5100              mov A,[__r0]
 01E0 5400              mov [X+0],A
 01E2                   .dbline 181
 01E2           ;       if(pwr < power_target) pwr += POWER_STEP;
 01E2 62D000            mov REG[0xd0],>_power_target
 01E5 5201              mov A,[X+1]
 01E7 1201              sub A,[_power_target+1]
 01E9 5200              mov A,[X+0]
 01EB 1A00              sbb A,[_power_target]
 01ED D006              jnc L28
 01EF           X7:
 01EF                   .dbline 181
 01EF 7701              inc [X+1]
 01F1 0F0000            adc [X+0],0
 01F4           L28:
 01F4                   .dbline 182
 01F4           ;       if(pwr > power_target) pwr -= POWER_STEP;
 01F4 62D000            mov REG[0xd0],>_power_target
 01F7 5101              mov A,[_power_target+1]
 01F9 1301              sub A,[X+1]
 01FB 5100              mov A,[_power_target]
 01FD 1B00              sbb A,[X+0]
 01FF D006              jnc L30
 0201           X8:
 0201                   .dbline 182
 0201 7B01              dec [X+1]
 0203 1F0000            sbb [X+0],0
 0206           L30:
 0206                   .dbline 183
 0206           ;       PWM16_CH0_WritePulseWidth(pwr);
 0206 10                push X
 0207 5200              mov A,[X+0]
 0209 08                push A
 020A 5201              mov A,[X+1]
 020C 20                pop X
 020D 7C0000            xcall _PWM16_CH0_WritePulseWidth
 0210                   .dbline 186
 0210           ;       
 0210           ;       // CH1
 0210           ;       pwr = PWM16_CH1_wReadPulseWidth();
 0210 7C0000            xcall _PWM16_CH1_wReadPulseWidth
 0213 62D000            mov REG[0xd0],>__r0
 0216 5A00              mov [__r0],X
 0218 20                pop X
 0219 5401              mov [X+1],A
 021B 5100              mov A,[__r0]
 021D 5400              mov [X+0],A
 021F                   .dbline 187
 021F           ;       if(pwr < power_target) pwr += POWER_STEP;
 021F 62D000            mov REG[0xd0],>_power_target
 0222 5201              mov A,[X+1]
 0224 1201              sub A,[_power_target+1]
 0226 5200              mov A,[X+0]
 0228 1A00              sbb A,[_power_target]
 022A D006              jnc L32
 022C           X9:
 022C                   .dbline 187
 022C 7701              inc [X+1]
 022E 0F0000            adc [X+0],0
 0231           L32:
 0231                   .dbline 188
 0231           ;       if(pwr > power_target) pwr -= POWER_STEP;
 0231 62D000            mov REG[0xd0],>_power_target
 0234 5101              mov A,[_power_target+1]
 0236 1301              sub A,[X+1]
 0238 5100              mov A,[_power_target]
 023A 1B00              sbb A,[X+0]
 023C D006              jnc L34
 023E           X10:
 023E                   .dbline 188
 023E 7B01              dec [X+1]
 0240 1F0000            sbb [X+0],0
 0243           L34:
 0243                   .dbline 189
 0243           ;       PWM16_CH1_WritePulseWidth(pwr);
 0243 10                push X
 0244 5200              mov A,[X+0]
 0246 08                push A
 0247 5201              mov A,[X+1]
 0249 20                pop X
 024A 7C0000            xcall _PWM16_CH1_WritePulseWidth
 024D 20                pop X
 024E                   .dbline -2
 024E           L27:
 024E 38FE              add SP,-2
 0250 20                pop X
 0251                   .dbline 0 ; func end
 0251 7F                ret
 0252                   .dbsym l pwr 0 i
 0252                   .dbend
 0252                   .dbfunc e schedule_processing _schedule_processing fV
 0252           ;              i -> X+0
 0252           ;           hour -> X-4
 0252           _schedule_processing::
 0252                   .dbline -1
 0252 10                push X
 0253 4F                mov X,SP
 0254 3801              add SP,1
 0256                   .dbline 193
 0256           ; }
 0256           ; 
 0256           ; void schedule_processing(unsigned char hour)
 0256           ; {
 0256                   .dbline 195
 0256           ;     unsigned char i; 
 0256           ;     for(i = 0; i < sizeof(schedule); i++)
 0256 560000            mov [X+0],0
 0259 806F              xjmp L40
 025B           L37:
 025B                   .dbline 196
 025B           ;     {
 025B                   .dbline 197
 025B           ;         if(hour == schedule[i][0])
 025B 62D000            mov REG[0xd0],>__r0
 025E 5200              mov A,[X+0]
 0260 5300              mov [__r1],A
 0262 550000            mov [__r0],0
 0265 6500              asl [__r1]
 0267 6B00              rlc [__r0]
 0269 6500              asl [__r1]
 026B 6B00              rlc [__r0]
 026D 060000            add [__r1],<_schedule
 0270 0E0000            adc [__r0],>_schedule
 0273 5100              mov A,[__r0]
 0275 10                push X
 0276 5800              mov X,[__r1]
 0278 08                push A
 0279 28                romx
 027A 5300              mov [__r0],A
 027C 18                pop A
 027D 75                inc X
 027E 0900              adc A,0
 0280 28                romx
 0281 5300              mov [__r1],A
 0283 20                pop X
 0284 52FC              mov A,[X-4]
 0286 5300              mov [__r3],A
 0288 5000              mov A,0
 028A 3A00              cmp A,[__r0]
 028C B03A              jnz L41
 028E 5100              mov A,[__r3]
 0290 3A00              cmp A,[__r1]
 0292 B034              jnz L41
 0294           X11:
 0294                   .dbline 199
 0294           ;         {
 0294           ;             set_power(schedule[i][1]);
 0294                   .dbline 199
 0294 62D000            mov REG[0xd0],>__r0
 0297 5200              mov A,[X+0]
 0299 5300              mov [__r1],A
 029B 550000            mov [__r0],0
 029E 6500              asl [__r1]
 02A0 6B00              rlc [__r0]
 02A2 6500              asl [__r1]
 02A4 6B00              rlc [__r0]
 02A6 060002            add [__r1],<_schedule+2
 02A9 0E0002            adc [__r0],>_schedule+2
 02AC 5100              mov A,[__r0]
 02AE 10                push X
 02AF 5800              mov X,[__r1]
 02B1 08                push A
 02B2 28                romx
 02B3 5300              mov [__r0],A
 02B5 18                pop A
 02B6 75                inc X
 02B7 0900              adc A,0
 02B9 28                romx
 02BA 5300              mov [__r1],A
 02BC 20                pop X
 02BD 5100              mov A,[__r0]
 02BF 08                push A
 02C0 5100              mov A,[__r1]
 02C2 08                push A
 02C3 9EEA              xcall _set_power
 02C5 38FE              add SP,-2
 02C7                   .dbline 200
 02C7           ;         }
 02C7           L41:
 02C7                   .dbline 201
 02C7           ;     }
 02C7           L38:
 02C7                   .dbline 195
 02C7 7700              inc [X+0]
 02C9           L40:
 02C9                   .dbline 195
 02C9 3D0008            cmp [X+0],8
 02CC CF8E              jc L37
 02CE           X12:
 02CE                   .dbline -2
 02CE           L36:
 02CE 38FF              add SP,-1
 02D0 20                pop X
 02D1                   .dbline 0 ; func end
 02D1 7F                ret
 02D2                   .dbsym l i 0 c
 02D2                   .dbsym l hour -4 c
 02D2                   .dbend
 02D2                   .dbfunc e schedule_init _schedule_init fV
 02D2           ;           hour -> X+0
 02D2           _schedule_init::
 02D2                   .dbline -1
 02D2 10                push X
 02D3 4F                mov X,SP
 02D4 3801              add SP,1
 02D6                   .dbline 205
 02D6           ; }
 02D6           ; 
 02D6           ; void schedule_init(void)
 02D6           ; {
 02D6                   .dbline 207
 02D6           ;     unsigned char hour;
 02D6           ;     for(hour = 0; hour <= bcd_to_byte(RTC_bReadHour()); hour++)
 02D6 560000            mov [X+0],0
 02D9 800A              xjmp L48
 02DB           L45:
 02DB                   .dbline 208
 02DB           ;     {
 02DB                   .dbline 209
 02DB           ;         schedule_processing(hour);
 02DB 5200              mov A,[X+0]
 02DD 08                push A
 02DE 9F72              xcall _schedule_processing
 02E0 38FF              add SP,-1
 02E2                   .dbline 210
 02E2           ;     }
 02E2           L46:
 02E2                   .dbline 207
 02E2 7700              inc [X+0]
 02E4           L48:
 02E4                   .dbline 207
 02E4 10                push X
 02E5 7C0000            xcall _RTC_bReadHour
 02E8 20                pop X
 02E9 62D000            mov REG[0xd0],>__r0
 02EC 08                push A
 02ED 944C              xcall _bcd_to_byte
 02EF 38FF              add SP,-1
 02F1 62D000            mov REG[0xd0],>__r0
 02F4 3B00              cmp A,[X+0]
 02F6 DFE4              jnc L45
 02F8           X13:
 02F8                   .dbline -2
 02F8           L44:
 02F8 38FF              add SP,-1
 02FA 20                pop X
 02FB                   .dbline 0 ; func end
 02FB 7F                ret
 02FC                   .dbsym l hour 0 c
 02FC                   .dbend
 02FC                   .dbfunc e rtc_update _rtc_update fV
 02FC           ;       datetime -> X-5
 02FC           _rtc_update::
 02FC                   .dbline -1
 02FC 10                push X
 02FD 4F                mov X,SP
 02FE                   .dbline 214
 02FE           ; }
 02FE           ; 
 02FE           ; void rtc_update(struct datetime *datetime)
 02FE           ; {
 02FE                   .dbline 215
 02FE           ;       RTC_Stop();
 02FE 10                push X
 02FF 7C0000            xcall _RTC_Stop
 0302 20                pop X
 0303                   .dbline 216
 0303           ;       RTC_SetHour(byte_to_bcd(datetime->hour));
 0303 62D000            mov REG[0xd0],>__r0
 0306 52FC              mov A,[X-4]
 0308 0102              add A,2
 030A 5300              mov [__r1],A
 030C 52FB              mov A,[X-5]
 030E 0900              adc A,0
 0310 60D4              mov REG[0xd4],A
 0312 3E00              mvi A,[__r1]
 0314 08                push A
 0315 93ED              xcall _byte_to_bcd
 0317 38FF              add SP,-1
 0319 62D000            mov REG[0xd0],>__r0
 031C 10                push X
 031D 7C0000            xcall _RTC_SetHour
 0320 20                pop X
 0321                   .dbline 217
 0321           ;       RTC_SetMinute(byte_to_bcd(datetime->min));
 0321 62D000            mov REG[0xd0],>__r0
 0324 52FC              mov A,[X-4]
 0326 0101              add A,1
 0328 5300              mov [__r1],A
 032A 52FB              mov A,[X-5]
 032C 0900              adc A,0
 032E 60D4              mov REG[0xd4],A
 0330 3E00              mvi A,[__r1]
 0332 08                push A
 0333 93CF              xcall _byte_to_bcd
 0335 38FF              add SP,-1
 0337 62D000            mov REG[0xd0],>__r0
 033A 10                push X
 033B 7C0000            xcall _RTC_SetMinute
 033E 20                pop X
 033F                   .dbline 218
 033F           ;       RTC_SetSecond(byte_to_bcd(datetime->sec));
 033F 62D000            mov REG[0xd0],>__r0
 0342 52FC              mov A,[X-4]
 0344 5300              mov [__r1],A
 0346 52FB              mov A,[X-5]
 0348 60D4              mov REG[0xd4],A
 034A 3E00              mvi A,[__r1]
 034C 08                push A
 034D 93B5              xcall _byte_to_bcd
 034F 38FF              add SP,-1
 0351 62D000            mov REG[0xd0],>__r0
 0354 10                push X
 0355 7C0000            xcall _RTC_SetSecond
 0358                   .dbline 219
 0358           ;       RTC_Start();
 0358 7C0000            xcall _RTC_Start
 035B 20                pop X
 035C                   .dbline -2
 035C           L49:
 035C 20                pop X
 035D                   .dbline 0 ; func end
 035D 7F                ret
 035E                   .dbsym l datetime -5 pS[datetime]
 035E                   .dbend
 035E                   .dbfunc e NMEA_GetField _NMEA_GetField fV
 035E           ;          count -> X+1
 035E           ;              i -> X+0
 035E           ;         result -> X-8
 035E           ;          field -> X-6
 035E           ;         packet -> X-5
 035E           _NMEA_GetField::
 035E                   .dbline -1
 035E 10                push X
 035F 4F                mov X,SP
 0360 3806              add SP,6
 0362                   .dbline 223
 0362           ; }
 0362           ; 
 0362           ; void NMEA_GetField(char *packet, unsigned char field, char *result)
 0362           ; {
 0362                   .dbline 225
 0362           ;     unsigned char i;
 0362           ;     unsigned char count = 0;
 0362 560100            mov [X+1],0
 0365                   .dbline 228
 0365           ;     
 0365           ;     // Search field
 0365           ;     for (i = 0; (i < NMEA_MAX_SIZE) & (count < field); i++)
 0365 560000            mov [X+0],0
 0368 803F              xjmp L54
 036A           L51:
 036A                   .dbline 229
 036A           ;     {
 036A                   .dbline 230
 036A           ;         if (packet[i] == NMEA_FIELD_DELIMITER) count++;
 036A 62D000            mov REG[0xd0],>__r0
 036D 5200              mov A,[X+0]
 036F 5300              mov [__r1],A
 0371 550000            mov [__r0],0
 0374 52FC              mov A,[X-4]
 0376 0400              add [__r1],A
 0378 52FB              mov A,[X-5]
 037A 0C00              adc [__r0],A
 037C 5100              mov A,[__r0]
 037E 60D4              mov REG[0xd4],A
 0380 3E00              mvi A,[__r1]
 0382 392C              cmp A,44
 0384 B003              jnz L57
 0386                   .dbline 230
 0386 7701              inc [X+1]
 0388           L57:
 0388                   .dbline 231
 0388           ;               if (packet[i] == 0) break;
 0388 62D000            mov REG[0xd0],>__r0
 038B 5200              mov A,[X+0]
 038D 5300              mov [__r1],A
 038F 550000            mov [__r0],0
 0392 52FC              mov A,[X-4]
 0394 0400              add [__r1],A
 0396 52FB              mov A,[X-5]
 0398 0C00              adc [__r0],A
 039A 5100              mov A,[__r0]
 039C 60D4              mov REG[0xd4],A
 039E 3E00              mvi A,[__r1]
 03A0 3900              cmp A,0
 03A2 B003              jnz L59
 03A4                   .dbline 231
 03A4 8040              xjmp L53
 03A6           L59:
 03A6                   .dbline 232
 03A6           ;     }
 03A6           L52:
 03A6                   .dbline 228
 03A6 7700              inc [X+0]
 03A8           L54:
 03A8                   .dbline 228
 03A8 3D0052            cmp [X+0],82
 03AB D009              jnc L61
 03AD           X14:
 03AD 560301            mov [X+3],1
 03B0 560200            mov [X+2],0
 03B3 8007              xjmp L62
 03B5           L61:
 03B5 560300            mov [X+3],0
 03B8 560200            mov [X+2],0
 03BB           L62:
 03BB 5201              mov A,[X+1]
 03BD 3BFA              cmp A,[X-6]
 03BF D009              jnc L63
 03C1           X15:
 03C1 560501            mov [X+5],1
 03C4 560400            mov [X+4],0
 03C7 8007              xjmp L64
 03C9           L63:
 03C9 560500            mov [X+5],0
 03CC 560400            mov [X+4],0
 03CF           L64:
 03CF 62D000            mov REG[0xd0],>__r0
 03D2 5203              mov A,[X+3]
 03D4 2305              and A,[X+5]
 03D6 5300              mov [__r1],A
 03D8 5202              mov A,[X+2]
 03DA 2304              and A,[X+4]
 03DC 3900              cmp A,0
 03DE BF8B              jnz L51
 03E0 3C0000            cmp [__r1],0
 03E3 BF86              jnz L51
 03E5           X16:
 03E5           L53:
 03E5                   .dbline 235
 03E5           ;     
 03E5           ;     // Measure field size
 03E5           ;     for (count = 0; count < NMEA_MAX_SIZE; count++)
 03E5 560100            mov [X+1],0
 03E8 8057              xjmp L68
 03EA           L65:
 03EA                   .dbline 236
 03EA           ;     {
 03EA                   .dbline 237
 03EA           ;         if (packet[i + count] == NMEA_FIELD_DELIMITER) break;
 03EA 62D000            mov REG[0xd0],>__r0
 03ED 5201              mov A,[X+1]
 03EF 5300              mov [__r1],A
 03F1 550000            mov [__r0],0
 03F4 5200              mov A,[X+0]
 03F6 0200              add A,[__r1]
 03F8 5300              mov [__r1],A
 03FA 5000              mov A,0
 03FC 0A00              adc A,[__r0]
 03FE 5300              mov [__r0],A
 0400 52FC              mov A,[X-4]
 0402 0400              add [__r1],A
 0404 52FB              mov A,[X-5]
 0406 0C00              adc [__r0],A
 0408 5100              mov A,[__r0]
 040A 60D4              mov REG[0xd4],A
 040C 3E00              mvi A,[__r1]
 040E 392C              cmp A,44
 0410 B003              jnz L69
 0412                   .dbline 237
 0412 8032              xjmp L67
 0414           L69:
 0414                   .dbline 238
 0414           ;         if (packet[i + count] == 0u) break;
 0414 62D000            mov REG[0xd0],>__r0
 0417 5201              mov A,[X+1]
 0419 5300              mov [__r1],A
 041B 550000            mov [__r0],0
 041E 5200              mov A,[X+0]
 0420 0200              add A,[__r1]
 0422 5300              mov [__r1],A
 0424 5000              mov A,0
 0426 0A00              adc A,[__r0]
 0428 5300              mov [__r0],A
 042A 52FC              mov A,[X-4]
 042C 0400              add [__r1],A
 042E 52FB              mov A,[X-5]
 0430 0C00              adc [__r0],A
 0432 5100              mov A,[__r0]
 0434 60D4              mov REG[0xd4],A
 0436 3E00              mvi A,[__r1]
 0438 3900              cmp A,0
 043A B003              jnz L71
 043C                   .dbline 238
 043C 8008              xjmp L67
 043E           L71:
 043E                   .dbline 239
 043E           ;     }
 043E           L66:
 043E                   .dbline 235
 043E 7701              inc [X+1]
 0440           L68:
 0440                   .dbline 235
 0440 3D0152            cmp [X+1],82
 0443 CFA6              jc L65
 0445           X17:
 0445           L67:
 0445                   .dbline 240
 0445           ;     strncpy(result, packet + i, count + 1);  // Add 1 to count for null terminator
 0445 62D000            mov REG[0xd0],>__r0
 0448 5201              mov A,[X+1]
 044A 5300              mov [__r1],A
 044C 550000            mov [__r0],0
 044F 060001            add [__r1],1
 0452 0E0000            adc [__r0],0
 0455 5100              mov A,[__r0]
 0457 08                push A
 0458 5100              mov A,[__r1]
 045A 08                push A
 045B 5200              mov A,[X+0]
 045D 5300              mov [__r1],A
 045F 550000            mov [__r0],0
 0462 52FC              mov A,[X-4]
 0464 0400              add [__r1],A
 0466 52FB              mov A,[X-5]
 0468 0C00              adc [__r0],A
 046A 5100              mov A,[__r0]
 046C 08                push A
 046D 5100              mov A,[__r1]
 046F 08                push A
 0470 52F8              mov A,[X-8]
 0472 08                push A
 0473 52F9              mov A,[X-7]
 0475 08                push A
 0476 7C0000            xcall _strncpy
 0479 38FA              add SP,-6
 047B                   .dbline 241
 047B           ;       result[count] = 0u;     // Add null terminator
 047B 62D000            mov REG[0xd0],>__r0
 047E 5201              mov A,[X+1]
 0480 5300              mov [__r1],A
 0482 550000            mov [__r0],0
 0485 52F9              mov A,[X-7]
 0487 0400              add [__r1],A
 0489 52F8              mov A,[X-8]
 048B 0C00              adc [__r0],A
 048D 5100              mov A,[__r0]
 048F 60D5              mov REG[0xd5],A
 0491 5000              mov A,0
 0493 3F00              mvi [__r1],A
 0495                   .dbline -2
 0495           L50:
 0495 38FA              add SP,-6
 0497 20                pop X
 0498                   .dbline 0 ; func end
 0498 7F                ret
 0499                   .dbsym l count 1 c
 0499                   .dbsym l i 0 c
 0499                   .dbsym l result -8 pc
 0499                   .dbsym l field -6 c
 0499                   .dbsym l packet -5 pc
 0499                   .dbend
 0499                   .dbfunc e NMEA_handle_packet _NMEA_handle_packet fV
 0499           ; calculated_checksum -> X+6
 0499           ; packet_checksum -> X+4
 0499           ;              n -> X+3
 0499           ;       checksum -> X+2
 0499           ;          error -> X+1
 0499           ;              i -> X+0
 0499           ;      NMEA_data -> X-7
 0499           ;         packet -> X-5
 0499           _NMEA_handle_packet::
 0499                   .dbline -1
 0499 10                push X
 049A 4F                mov X,SP
 049B 380F              add SP,15
 049D                   .dbline 245
 049D           ; }
 049D           ; 
 049D           ; void NMEA_handle_packet(char *packet, char *NMEA_data)
 049D           ; {
 049D                   .dbline 247
 049D           ;     unsigned char i, n;
 049D           ;     unsigned char error = 0;
 049D 560100            mov [X+1],0
 04A0                   .dbline 248
 04A0           ;     unsigned char checksum = 0;
 04A0 560200            mov [X+2],0
 04A3                   .dbline 253
 04A3           ;     char *packet_checksum;
 04A3           ;     char calculated_checksum[3];
 04A3           ;         
 04A3           ;     // Check if appropriate packet is handled
 04A3           ;       if (str_cmp(packet, NMEA_data, NMEA_HEADER_SIZE) == 0u)
 04A3 5003              mov A,3
 04A5 08                push A
 04A6 52F9              mov A,[X-7]
 04A8 08                push A
 04A9 52FA              mov A,[X-6]
 04AB 08                push A
 04AC 52FB              mov A,[X-5]
 04AE 08                push A
 04AF 52FC              mov A,[X-4]
 04B1 08                push A
 04B2 91FF              xcall _str_cmp
 04B4 38FB              add SP,-5
 04B6 62D000            mov REG[0xd0],>__r0
 04B9 3900              cmp A,0
 04BB B0E7              jnz L74
 04BD                   .dbline 256
 04BD           ;     {
 04BD           ;               // Check for receive errors
 04BD           ;         for(i = 0; i < NMEA_MAX_SIZE; i++)
 04BD                   .dbline 256
 04BD 560000            mov [X+0],0
 04C0 80C1              xjmp L79
 04C2           L76:
 04C2                   .dbline 257
 04C2           ;         {
 04C2                   .dbline 258
 04C2           ;             if ((packet[i] < 32) & (packet[i] != 0x0D) & (packet[i] != NMEA_END_DELIMITER)) 
 04C2 62D000            mov REG[0xd0],>__r0
 04C5 5200              mov A,[X+0]
 04C7 5300              mov [__r1],A
 04C9 550000            mov [__r0],0
 04CC 52FC              mov A,[X-4]
 04CE 0400              add [__r1],A
 04D0 52FB              mov A,[X-5]
 04D2 0C00              adc [__r0],A
 04D4 5100              mov A,[__r0]
 04D6 60D4              mov REG[0xd4],A
 04D8 3E00              mvi A,[__r1]
 04DA 3920              cmp A,32
 04DC D009              jnc L85
 04DE           X18:
 04DE 560A01            mov [X+10],1
 04E1 560900            mov [X+9],0
 04E4 8007              xjmp L86
 04E6           L85:
 04E6 560A00            mov [X+10],0
 04E9 560900            mov [X+9],0
 04EC           L86:
 04EC 62D000            mov REG[0xd0],>__r0
 04EF 5200              mov A,[X+0]
 04F1 5300              mov [__r1],A
 04F3 550000            mov [__r0],0
 04F6 52FC              mov A,[X-4]
 04F8 0400              add [__r1],A
 04FA 52FB              mov A,[X-5]
 04FC 0C00              adc [__r0],A
 04FE 5100              mov A,[__r0]
 0500 60D4              mov REG[0xd4],A
 0502 3E00              mvi A,[__r1]
 0504 390D              cmp A,13
 0506 A009              jz L87
 0508 560C01            mov [X+12],1
 050B 560B00            mov [X+11],0
 050E 8007              xjmp L88
 0510           L87:
 0510 560C00            mov [X+12],0
 0513 560B00            mov [X+11],0
 0516           L88:
 0516 62D000            mov REG[0xd0],>__r0
 0519 5200              mov A,[X+0]
 051B 5300              mov [__r1],A
 051D 550000            mov [__r0],0
 0520 52FC              mov A,[X-4]
 0522 0400              add [__r1],A
 0524 52FB              mov A,[X-5]
 0526 0C00              adc [__r0],A
 0528 5100              mov A,[__r0]
 052A 60D4              mov REG[0xd4],A
 052C 3E00              mvi A,[__r1]
 052E 390A              cmp A,10
 0530 A009              jz L89
 0532 560E01            mov [X+14],1
 0535 560D00            mov [X+13],0
 0538 8007              xjmp L90
 053A           L89:
 053A 560E00            mov [X+14],0
 053D 560D00            mov [X+13],0
 0540           L90:
 0540 62D000            mov REG[0xd0],>__r0
 0543 520A              mov A,[X+10]
 0545 230C              and A,[X+12]
 0547 5300              mov [__r1],A
 0549 5209              mov A,[X+9]
 054B 230B              and A,[X+11]
 054D 5300              mov [__r0],A
 054F 520E              mov A,[X+14]
 0551 2400              and [__r1],A
 0553 520D              mov A,[X+13]
 0555 2400              and [__r0],A
 0557 B006              jnz X19
 0559 3C0000            cmp [__r1],0
 055C A005              jz L80
 055E           X19:
 055E                   .dbline 260
 055E           ;             {
 055E           ;                 error++;
 055E                   .dbline 260
 055E 7701              inc [X+1]
 0560                   .dbline 261
 0560           ;                 break;
 0560 8026              xjmp L78
 0562           L80:
 0562                   .dbline 263
 0562           ;             }
 0562           ;             if (packet[i] != NMEA_END_DELIMITER) break;
 0562 62D000            mov REG[0xd0],>__r0
 0565 5200              mov A,[X+0]
 0567 5300              mov [__r1],A
 0569 550000            mov [__r0],0
 056C 52FC              mov A,[X-4]
 056E 0400              add [__r1],A
 0570 52FB              mov A,[X-5]
 0572 0C00              adc [__r0],A
 0574 5100              mov A,[__r0]
 0576 60D4              mov REG[0xd4],A
 0578 3E00              mvi A,[__r1]
 057A 390A              cmp A,10
 057C A003              jz L91
 057E                   .dbline 263
 057E 8008              xjmp L78
 0580           L91:
 0580                   .dbline 264
 0580           ;         }
 0580           L77:
 0580                   .dbline 256
 0580 7700              inc [X+0]
 0582           L79:
 0582                   .dbline 256
 0582 3D0052            cmp [X+0],82
 0585 CF3C              jc L76
 0587           X20:
 0587           L78:
 0587                   .dbline 267
 0587           ;               
 0587           ;         // Copy buffer to NMEA packet if no errors found
 0587           ;         if (!error) strncpy(NMEA_data, packet, NMEA_MAX_SIZE);
 0587 3D0100            cmp [X+1],0
 058A B018              jnz L93
 058C                   .dbline 267
 058C 5000              mov A,0
 058E 08                push A
 058F 5052              mov A,82
 0591 08                push A
 0592 52FB              mov A,[X-5]
 0594 08                push A
 0595 52FC              mov A,[X-4]
 0597 08                push A
 0598 52F9              mov A,[X-7]
 059A 08                push A
 059B 52FA              mov A,[X-6]
 059D 08                push A
 059E 7C0000            xcall _strncpy
 05A1 38FA              add SP,-6
 05A3           L93:
 05A3                   .dbline 268
 05A3           ;     }
 05A3           L74:
 05A3                   .dbline -2
 05A3           L73:
 05A3 38F1              add SP,-15
 05A5 20                pop X
 05A6                   .dbline 0 ; func end
 05A6 7F                ret
 05A7                   .dbsym l calculated_checksum 6 A[3:3]c
 05A7                   .dbsym l packet_checksum 4 pc
 05A7                   .dbsym l n 3 c
 05A7                   .dbsym l checksum 2 c
 05A7                   .dbsym l error 1 c
 05A7                   .dbsym l i 0 c
 05A7                   .dbsym l NMEA_data -7 pc
 05A7                   .dbsym l packet -5 pc
 05A7                   .dbend
 05A7                   .dbfunc e NMEA_GetTimeUTC _NMEA_GetTimeUTC fV
 05A7           ;          field -> X+82
 05A7           ;            buf -> X+0
 05A7           ;   gps_datetime -> X-7
 05A7           ;          gprmc -> X-5
 05A7           _NMEA_GetTimeUTC::
 05A7                   .dbline -1
 05A7 10                push X
 05A8 4F                mov X,SP
 05A9 38A4              add SP,-92
 05AB                   .dbline 272
 05AB           ; }
 05AB           ; 
 05AB           ; void NMEA_GetTimeUTC(char *gprmc, struct datetime *gps_datetime)
 05AB           ; {
 05AB                   .dbline 281
 05AB           ;       #define POS_SIZE        2
 05AB           ;       #define POS_HOUR        0
 05AB           ;       #define POS_MIN         2
 05AB           ;       #define POS_SEC         4
 05AB           ;       
 05AB           ;       char field[NMEA_MAX_SIZE];
 05AB           ;       char buf[NMEA_MAX_SIZE];
 05AB           ;       
 05AB           ;       NMEA_GetField(gprmc, NMEA_GPRMC_UTC, field);
 05AB 62D000            mov REG[0xd0],>__r0
 05AE 5A00              mov [__r1],X
 05B0 060052            add [__r1],82
 05B3 5003              mov A,3
 05B5 08                push A
 05B6 5100              mov A,[__r1]
 05B8 08                push A
 05B9 5001              mov A,1
 05BB 08                push A
 05BC 52FB              mov A,[X-5]
 05BE 08                push A
 05BF 52FC              mov A,[X-4]
 05C1 08                push A
 05C2 9D9A              xcall _NMEA_GetField
 05C4 38FB              add SP,-5
 05C6                   .dbline 282
 05C6           ;       if (field[0] != 0)
 05C6 3D5200            cmp [X+82],0
 05C9 A0D0              jz L96
 05CB                   .dbline 285
 05CB           ;       {
 05CB           ;               // Hour
 05CB           ;               strncpy(buf, field + POS_HOUR, POS_SIZE);
 05CB                   .dbline 285
 05CB 5000              mov A,0
 05CD 08                push A
 05CE 5002              mov A,2
 05D0 08                push A
 05D1 62D000            mov REG[0xd0],>__r0
 05D4 5A00              mov [__r1],X
 05D6 060052            add [__r1],82
 05D9 5003              mov A,3
 05DB 08                push A
 05DC 5100              mov A,[__r1]
 05DE 08                push A
 05DF 5003              mov A,3
 05E1 08                push A
 05E2 10                push X
 05E3 7C0000            xcall _strncpy
 05E6                   .dbline 286
 05E6           ;               buf[POS_SIZE] = 0;      // Add null terminator
 05E6 560200            mov [X+2],0
 05E9                   .dbline 287
 05E9           ;               gps_datetime->hour = atoi(buf);
 05E9 62D000            mov REG[0xd0],>__r0
 05EC 5003              mov A,3
 05EE 08                push A
 05EF 10                push X
 05F0 7C0000            xcall _atoi
 05F3 38F8              add SP,-8
 05F5 62D000            mov REG[0xd0],>__r0
 05F8 5100              mov A,[__r1]
 05FA 5300              mov [__r0],A
 05FC 52FA              mov A,[X-6]
 05FE 0102              add A,2
 0600 5300              mov [__r3],A
 0602 52F9              mov A,[X-7]
 0604 0900              adc A,0
 0606 60D5              mov REG[0xd5],A
 0608 5100              mov A,[__r0]
 060A 3F00              mvi [__r3],A
 060C                   .dbline 290
 060C           ;               
 060C           ;               // Minutes
 060C           ;               strncpy(buf, field + POS_MIN, POS_SIZE);
 060C 5000              mov A,0
 060E 08                push A
 060F 5002              mov A,2
 0611 08                push A
 0612 5A00              mov [__r1],X
 0614 060054            add [__r1],84
 0617 5003              mov A,3
 0619 08                push A
 061A 5100              mov A,[__r1]
 061C 08                push A
 061D 5003              mov A,3
 061F 08                push A
 0620 10                push X
 0621 7C0000            xcall _strncpy
 0624                   .dbline 291
 0624           ;               buf[POS_SIZE] = 0;      // Add null terminator
 0624 560200            mov [X+2],0
 0627                   .dbline 292
 0627           ;               gps_datetime->min = atoi(buf);
 0627 62D000            mov REG[0xd0],>__r0
 062A 5003              mov A,3
 062C 08                push A
 062D 10                push X
 062E 7C0000            xcall _atoi
 0631 38F8              add SP,-8
 0633 62D000            mov REG[0xd0],>__r0
 0636 5100              mov A,[__r1]
 0638 5300              mov [__r0],A
 063A 52FA              mov A,[X-6]
 063C 0101              add A,1
 063E 5300              mov [__r3],A
 0640 52F9              mov A,[X-7]
 0642 0900              adc A,0
 0644 60D5              mov REG[0xd5],A
 0646 5100              mov A,[__r0]
 0648 3F00              mvi [__r3],A
 064A                   .dbline 295
 064A           ;               
 064A           ;               // Seconds
 064A           ;               strncpy(buf, field + POS_SEC, POS_SIZE);
 064A 5000              mov A,0
 064C 08                push A
 064D 5002              mov A,2
 064F 08                push A
 0650 5A00              mov [__r1],X
 0652 060056            add [__r1],86
 0655 5003              mov A,3
 0657 08                push A
 0658 5100              mov A,[__r1]
 065A 08                push A
 065B 5003              mov A,3
 065D 08                push A
 065E 10                push X
 065F 7C0000            xcall _strncpy
 0662                   .dbline 296
 0662           ;               buf[POS_SIZE] = 0;      // Add null terminator
 0662 560200            mov [X+2],0
 0665                   .dbline 297
 0665           ;               gps_datetime->sec = atoi(buf);
 0665 62D000            mov REG[0xd0],>__r0
 0668 5003              mov A,3
 066A 08                push A
 066B 10                push X
 066C 7C0000            xcall _atoi
 066F 38F8              add SP,-8
 0671 62D000            mov REG[0xd0],>__r0
 0674 5100              mov A,[__r1]
 0676 5300              mov [__r0],A
 0678 52FA              mov A,[X-6]
 067A 5300              mov [__r3],A
 067C 52F9              mov A,[X-7]
 067E 60D5              mov REG[0xd5],A
 0680 5100              mov A,[__r0]
 0682 3F00              mvi [__r3],A
 0684                   .dbline 299
 0684           ;               
 0684           ;               gps_datetime->valid = true;
 0684 52FA              mov A,[X-6]
 0686 0106              add A,6
 0688 5300              mov [__r1],A
 068A 52F9              mov A,[X-7]
 068C 0900              adc A,0
 068E 60D5              mov REG[0xd5],A
 0690 5000              mov A,0
 0692 3F00              mvi [__r1],A
 0694 5001              mov A,1
 0696 3F00              mvi [__r1],A
 0698                   .dbline 300
 0698           ;       }
 0698 8016              xjmp L97
 069A           L96:
 069A                   .dbline 301
 069A           ;       else gps_datetime->valid = false;
 069A 62D000            mov REG[0xd0],>__r0
 069D 52FA              mov A,[X-6]
 069F 0106              add A,6
 06A1 5300              mov [__r1],A
 06A3 52F9              mov A,[X-7]
 06A5 0900              adc A,0
 06A7 60D5              mov REG[0xd5],A
 06A9 5000              mov A,0
 06AB 3F00              mvi [__r1],A
 06AD 3F00              mvi [__r1],A
 06AF           L97:
 06AF                   .dbline -2
 06AF           L95:
 06AF 385C              add SP,-164
 06B1 20                pop X
 06B2                   .dbline 0 ; func end
 06B2 7F                ret
 06B3                   .dbsym l field 82 A[82:82]c
 06B3                   .dbsym l buf 0 A[82:82]c
 06B3                   .dbsym l gps_datetime -7 pS[datetime]
 06B3                   .dbsym l gprmc -5 pc
 06B3                   .dbend
 06B3                   .dbfunc e str_cmp _str_cmp fc
 06B3           ;              i -> X+0
 06B3           ;           stop -> X-8
 06B3           ;           str2 -> X-7
 06B3           ;           str1 -> X-5
 06B3           _str_cmp::
 06B3                   .dbline -1
 06B3 10                push X
 06B4 4F                mov X,SP
 06B5 3801              add SP,1
 06B7                   .dbline 305
 06B7           ; }
 06B7           ; 
 06B7           ; unsigned char str_cmp(char *str1, char *str2, unsigned char stop)
 06B7           ; {
 06B7                   .dbline 307
 06B7           ;     unsigned char i;
 06B7           ;     for(i = 0u; i <= stop; i++)
 06B7 560000            mov [X+0],0
 06BA 803A              xjmp L107
 06BC           L104:
 06BC                   .dbline 308
 06BC           ;     {
 06BC                   .dbline 309
 06BC           ;         if (str1[i] != str2[i]) return 1u;
 06BC 62D000            mov REG[0xd0],>__r0
 06BF 5200              mov A,[X+0]
 06C1 5300              mov [__r1],A
 06C3 550000            mov [__r0],0
 06C6 52FA              mov A,[X-6]
 06C8 0400              add [__r1],A
 06CA 52F9              mov A,[X-7]
 06CC 0C00              adc [__r0],A
 06CE 5100              mov A,[__r0]
 06D0 60D4              mov REG[0xd4],A
 06D2 3E00              mvi A,[__r1]
 06D4 5300              mov [__r0],A
 06D6 5200              mov A,[X+0]
 06D8 5300              mov [__r3],A
 06DA 550000            mov [__r2],0
 06DD 52FC              mov A,[X-4]
 06DF 0400              add [__r3],A
 06E1 52FB              mov A,[X-5]
 06E3 0C00              adc [__r2],A
 06E5 5100              mov A,[__r2]
 06E7 60D4              mov REG[0xd4],A
 06E9 3E00              mvi A,[__r3]
 06EB 3A00              cmp A,[__r0]
 06ED A005              jz L108
 06EF                   .dbline 309
 06EF 5001              mov A,1
 06F1 800E              xjmp L103
 06F3           L108:
 06F3                   .dbline 310
 06F3           ;     }
 06F3           L105:
 06F3                   .dbline 307
 06F3 7700              inc [X+0]
 06F5           L107:
 06F5                   .dbline 307
 06F5 52F8              mov A,[X-8]
 06F7 3B00              cmp A,[X+0]
 06F9 DFC2              jnc L104
 06FB           X21:
 06FB                   .dbline 311
 06FB           ;     return 0u;
 06FB 62D000            mov REG[0xd0],>__r0
 06FE 5000              mov A,0
 0700                   .dbline -2
 0700           L103:
 0700 38FF              add SP,-1
 0702 20                pop X
 0703                   .dbline 0 ; func end
 0703 7F                ret
 0704                   .dbsym l i 0 c
 0704                   .dbsym l stop -8 c
 0704                   .dbsym l str2 -7 pc
 0704                   .dbsym l str1 -5 pc
 0704                   .dbend
 0704                   .dbfunc e byte_to_bcd _byte_to_bcd fc
 0704           ;            reg -> X+2
 0704           ;            low -> X+1
 0704           ;           high -> X+0
 0704           ;           byte -> X-4
 0704           _byte_to_bcd::
 0704                   .dbline -1
 0704 10                push X
 0705 4F                mov X,SP
 0706 3803              add SP,3
 0708                   .dbline 315
 0708           ; }
 0708           ; 
 0708           ; unsigned char byte_to_bcd(unsigned char byte)
 0708           ; {
 0708                   .dbline 318
 0708           ;     unsigned char high, low, reg;
 0708           ;     
 0708           ;     high = byte / DECIMAL_COUNT_SYSTEM_BASIS;
 0708 500A              mov A,10
 070A 08                push A
 070B 52FC              mov A,[X-4]
 070D 08                push A
 070E 62D000            mov REG[0xd0],>__r0
 0711 7C0000            xcall __divmodu_8X8_8
 0714 18                pop A
 0715 5400              mov [X+0],A
 0717 38FF              add SP,-1
 0719                   .dbline 319
 0719           ;     low = byte - high * DECIMAL_COUNT_SYSTEM_BASIS;
 0719 5200              mov A,[X+0]
 071B 60E8              mov REG[0xe8],A
 071D 62E90A            mov REG[0xe9],10
 0720 40                nop
 0721 5DEB              mov A,REG[0xeb]
 0723 5300              mov [__r0],A
 0725 52FC              mov A,[X-4]
 0727 1200              sub A,[__r0]
 0729 5401              mov [X+1],A
 072B                   .dbline 320
 072B           ;     reg = (high << DECIMAL_NUMBER_SIZE) + low;
 072B 5200              mov A,[X+0]
 072D 64                asl A
 072E 64                asl A
 072F 64                asl A
 0730 64                asl A
 0731 0301              add A,[X+1]
 0733 5402              mov [X+2],A
 0735                   .dbline 322
 0735           ;     
 0735           ;     return reg;
 0735 5202              mov A,[X+2]
 0737                   .dbline -2
 0737           L110:
 0737 38FD              add SP,-3
 0739 20                pop X
 073A                   .dbline 0 ; func end
 073A 7F                ret
 073B                   .dbsym l reg 2 c
 073B                   .dbsym l low 1 c
 073B                   .dbsym l high 0 c
 073B                   .dbsym l byte -4 c
 073B                   .dbend
 073B                   .dbfunc e bcd_to_byte _bcd_to_byte fc
 073B           ;           byte -> X+2
 073B           ;            low -> X+1
 073B           ;           high -> X+0
 073B           ;            reg -> X-4
 073B           _bcd_to_byte::
 073B                   .dbline -1
 073B 10                push X
 073C 4F                mov X,SP
 073D 3803              add SP,3
 073F                   .dbline 326
 073F           ; }
 073F           ; 
 073F           ; unsigned char bcd_to_byte(unsigned char reg)
 073F           ; {
 073F                   .dbline 329
 073F           ;     unsigned char high, low, byte;
 073F           ;     
 073F           ;     high = (reg >> DECIMAL_NUMBER_SIZE);
 073F 52FC              mov A,[X-4]
 0741 62D000            mov REG[0xd0],>__r0
 0744 67                asr A
 0745 67                asr A
 0746 67                asr A
 0747 67                asr A
 0748 210F              and A,15
 074A 5400              mov [X+0],A
 074C                   .dbline 330
 074C           ;     low = reg - (high << DECIMAL_NUMBER_SIZE);
 074C 5200              mov A,[X+0]
 074E 64                asl A
 074F 64                asl A
 0750 64                asl A
 0751 64                asl A
 0752 5300              mov [__r0],A
 0754 52FC              mov A,[X-4]
 0756 1200              sub A,[__r0]
 0758 5401              mov [X+1],A
 075A                   .dbline 331
 075A           ;     byte = low + high * DECIMAL_COUNT_SYSTEM_BASIS;
 075A 5200              mov A,[X+0]
 075C 60E8              mov REG[0xe8],A
 075E 62E90A            mov REG[0xe9],10
 0761 40                nop
 0762 5DEB              mov A,REG[0xeb]
 0764 5300              mov [__r0],A
 0766 5201              mov A,[X+1]
 0768 0200              add A,[__r0]
 076A 5402              mov [X+2],A
 076C                   .dbline 333
 076C           ; 
 076C           ;     return byte;
 076C 5202              mov A,[X+2]
 076E                   .dbline -2
 076E           L111:
 076E 38FD              add SP,-3
 0770 20                pop X
 0771                   .dbline 0 ; func end
 0771 7F                ret
 0772                   .dbsym l byte 2 c
 0772                   .dbsym l low 1 c
 0772                   .dbsym l high 0 c
 0772                   .dbsym l reg -4 c
 0772                   .dbend
 0772                   .dbfunc e utc_to_local _utc_to_local fV
 0772           ; local_datetime -> X-7
 0772           ;   utc_datetime -> X-5
 0772           _utc_to_local::
 0772                   .dbline -1
 0772 10                push X
 0773 4F                mov X,SP
 0774                   .dbline 337
 0774           ; }
 0774           ; 
 0774           ; void utc_to_local(struct datetime *utc_datetime, struct datetime *local_datetime)
 0774           ; {
 0774                   .dbline 338
 0774           ;       local_datetime->valid = utc_datetime->valid;
 0774 62D000            mov REG[0xd0],>__r0
 0777 52FC              mov A,[X-4]
 0779 0106              add A,6
 077B 5300              mov [__r1],A
 077D 52FB              mov A,[X-5]
 077F 0900              adc A,0
 0781 60D4              mov REG[0xd4],A
 0783 3E00              mvi A,[__r1]
 0785 5300              mov [__r0],A
 0787 3E00              mvi A,[__r1]
 0789 5300              mov [__r1],A
 078B 52FA              mov A,[X-6]
 078D 0106              add A,6
 078F 5300              mov [__r3],A
 0791 52F9              mov A,[X-7]
 0793 0900              adc A,0
 0795 60D5              mov REG[0xd5],A
 0797 5100              mov A,[__r0]
 0799 3F00              mvi [__r3],A
 079B 5100              mov A,[__r1]
 079D 3F00              mvi [__r3],A
 079F                   .dbline 339
 079F           ;       local_datetime->sec = utc_datetime->sec;
 079F 52FC              mov A,[X-4]
 07A1 5300              mov [__r1],A
 07A3 52FB              mov A,[X-5]
 07A5 60D4              mov REG[0xd4],A
 07A7 3E00              mvi A,[__r1]
 07A9 5300              mov [__r0],A
 07AB 52FA              mov A,[X-6]
 07AD 5300              mov [__r3],A
 07AF 52F9              mov A,[X-7]
 07B1 60D5              mov REG[0xd5],A
 07B3 5100              mov A,[__r0]
 07B5 3F00              mvi [__r3],A
 07B7                   .dbline 340
 07B7           ;       local_datetime->min = utc_datetime->min;
 07B7 52FC              mov A,[X-4]
 07B9 0101              add A,1
 07BB 5300              mov [__r1],A
 07BD 52FB              mov A,[X-5]
 07BF 0900              adc A,0
 07C1 60D4              mov REG[0xd4],A
 07C3 3E00              mvi A,[__r1]
 07C5 5300              mov [__r0],A
 07C7 52FA              mov A,[X-6]
 07C9 0101              add A,1
 07CB 5300              mov [__r3],A
 07CD 52F9              mov A,[X-7]
 07CF 0900              adc A,0
 07D1 60D5              mov REG[0xd5],A
 07D3 5100              mov A,[__r0]
 07D5 3F00              mvi [__r3],A
 07D7                   .dbline 341
 07D7           ;       local_datetime->hour = utc_datetime->hour + GMT_OFFSET;
 07D7 52FC              mov A,[X-4]
 07D9 0102              add A,2
 07DB 5300              mov [__r1],A
 07DD 52FB              mov A,[X-5]
 07DF 0900              adc A,0
 07E1 60D4              mov REG[0xd4],A
 07E3 3E00              mvi A,[__r1]
 07E5 5300              mov [__r0],A
 07E7 060003            add [__r0],3
 07EA 52FA              mov A,[X-6]
 07EC 0102              add A,2
 07EE 5300              mov [__r3],A
 07F0 52F9              mov A,[X-7]
 07F2 0900              adc A,0
 07F4 60D5              mov REG[0xd5],A
 07F6 5100              mov A,[__r0]
 07F8 3F00              mvi [__r3],A
 07FA                   .dbline 342
 07FA           ;       if (local_datetime->hour > HOUR_MAX) local_datetime->hour -= (HOUR_MAX + 1);
 07FA 52FA              mov A,[X-6]
 07FC 0102              add A,2
 07FE 5300              mov [__r1],A
 0800 52F9              mov A,[X-7]
 0802 0900              adc A,0
 0804 60D4              mov REG[0xd4],A
 0806 3E00              mvi A,[__r1]
 0808 5300              mov [__r0],A
 080A 5017              mov A,23
 080C 3A00              cmp A,[__r0]
 080E D023              jnc L113
 0810           X22:
 0810                   .dbline 342
 0810 62D000            mov REG[0xd0],>__r0
 0813 52FA              mov A,[X-6]
 0815 0102              add A,2
 0817 5300              mov [__r1],A
 0819 52F9              mov A,[X-7]
 081B 0900              adc A,0
 081D 5300              mov [__r0],A
 081F 60D4              mov REG[0xd4],A
 0821 3E00              mvi A,[__r1]
 0823 7A00              dec [__r1]
 0825 5300              mov [__r2],A
 0827 160018            sub [__r2],24
 082A 5100              mov A,[__r0]
 082C 60D5              mov REG[0xd5],A
 082E 5100              mov A,[__r2]
 0830 3F00              mvi [__r1],A
 0832           L113:
 0832                   .dbline -2
 0832           L112:
 0832 20                pop X
 0833                   .dbline 0 ; func end
 0833 7F                ret
 0834                   .dbsym l local_datetime -7 pS[datetime]
 0834                   .dbsym l utc_datetime -5 pS[datetime]
 0834                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Work\FitoLamp\FW\Slave\FITOLA~1\FITOLA~1\FITOLA~1\main.c
 0000           _NMEA_pointer::
 0000 00                .byte 0
 0001                   .dbsym e NMEA_pointer _NMEA_pointer c
                        .area lit(rom, con, rel, lit)
 0008           L12:
 0008 2000              .byte 32,0
